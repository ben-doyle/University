package planner.gui;

import planner.*;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * The model for the event allocator program.
 *
 * Invariant:
 *          venues contains only venues read from venues.txt &&
 *          events contains events that have been added &&
 *          allocation != null && only contain current allocations &&
 *          currentMessage only contains correct message/Error message &&
 *          TrafficGenerated contains the current traffic generated by the
 *          allocation &&
 *          error is only true when an error has occurred.
 */
public class EventAllocatorModel {

    // Correct line separator for executing machine (used in toString method)
    private final static String NEW_LINE = System.getProperty(
            "line.separator");
    //Current list of venues that were have been loaded.
    private List<Venue> venues;
    //Current list of events that were have been entered.
    private List<Event> events = new ArrayList<>();
    //The current allocation from events to venues.
    private HashMap<Event, Venue> allocation = new HashMap<>();
    //The current message/Error message.
    private String currentMessage;
    //The traffic generated by the current allocation.
    private Traffic trafficGenerated;
    //Current error state of the application.
    private boolean error = false;

    /**
     * Initialises the model for the event allocator program.
     */
    EventAllocatorModel() {
        try {
            venues = new ArrayList<>();
            loadFile("venues.txt");
            currentMessage = "Venues from venues.txt loaded successfully " +
                    NEW_LINE + NEW_LINE + "No current allocation.";
        } catch (Exception e) {
            error = true;
            currentMessage = "Error loading venues.txt: " + e.getMessage() +
                    NEW_LINE + "Functionality disabled, fix and restart " +
                    "application";
        }
    }

    /**
     * Calculates the traffic generated by the allocation.
     *
     * @return the traffic generated by an allocation
     */
    Traffic trafficGenerated() {
        trafficGenerated = new Traffic();
        for (Event e : allocation.keySet()) {
            trafficGenerated.addTraffic(allocation.get(e).getTraffic(e));
        }
        return new Traffic(trafficGenerated);
    }

    /**
     * Checks if the traffic generated by an allocation is safe.
     *
     * @return true if safe, false otherwise.
     */
    boolean isTrafficGeneratedSafe() {
        return trafficGenerated.isSafe();
    }

    /**
     * Checks if there is a current error.
     *
     * @return true if there is a current error, false otherwise
     */
    public boolean getError() {
        return error;
    }

    /**
     * Get the current message/Error message.
     *
     * @return the String message/Error Message.
     */
    String getCurrentMsg() {
        return currentMessage;
    }

    /**
     * Method to load the file.
     *
     * @param fileName uses venue.txt in working directory.
     * @throws IOException     If there is a problem loading the file.
     * @throws FormatException If the file is not formatted correctly.
     */
    private void loadFile(String fileName) throws IOException, FormatException {
        venues.addAll(VenueReader.read(fileName));
    }

    /**
     * Adds an event.
     */
    void addEvent(Event e) {
        events.add(e);
    }

    /**
     * Get events.
     *
     * @return current list of events
     */
    public List<Event> getEvents() {
        return new ArrayList<>(events);
    }

    /**
     * Get venues.
     *
     * @return current list of venues.
     */
    public List<Venue> getVenues() {
        return new ArrayList<>(venues);
    }

    /**
     * Add an allocation.
     */
    void addAllocation(Event event, Venue venue) {
        allocation.put(event, venue);
    }

    /**
     * Get allocation.
     *
     * @return the current allocation.
     */
    public HashMap<Event, Venue> getAllocation() {
        return new HashMap<>(allocation);
    }

    /**
     * Remove an event.
     *
     * @return true if successful, false otherwise.
     */
    boolean removeEvent(Event e) {
        if (allocation.containsKey(e)) {
            allocation.remove(e);
            events.remove(e);
            return true;
        }
        return false;

    }

    boolean isAllocated(Venue addEventVenue) {
        return getAllocation().containsValue(addEventVenue);
    }

}

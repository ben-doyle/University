package planner;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * Provides a method to read in a list of venues from a text file.
 */
public class VenueReader {

    /**
     * <p>
     * Reads a text file called fileName that describes the venues in a
     * municipality, and returns a list containing each of the venues read from
     * the file, in the order that they appear in the file.
     * </p>
     * <p>
     * <p>
     * The file contains zero or more descriptions of different venues. (I.e. a
     * file containing zero venues contains zero lines; a file containing one
     * venue contains exactly one description of a venue and no other lines or
     * information; a file containing multiple venues contains each description
     * of a venue, one after the other with no other information or lines in the
     * file.)
     * </p>
     * <p>
     * <p>
     * A description of a venue consists of exactly (i) one line consisting of
     * the name of the venue followed by (ii) one line containing a positive
     * integer denoting the capacity of the venue followed by (iii) a
     * description of the traffic generated by hosting an event of maximum size
     * at the venue, followed by (iv) an empty line.
     * </p>
     * <p>
     * <p>
     * For (i) the venue name is the entire string on the first line of the
     * venue description (i.e. it may contain white space characters etc.). The
     * only constraint on the venue name is that it may not be equal to the
     * empty string ("").
     * </p>
     * <p>
     * <p>
     * For (ii) the second line of a venue description may not contain leading
     * or trailing whitespace characters, it may only contain a positive integer
     * denoting the venue capacity.
     * </p>
     * <p>
     * <p>
     * For (iii) the traffic is described by one line for each corridor that
     * will have traffic from the venue when it hosts an event of maximum size.
     * Each line is a string of the form <br>
     * <br>
     * "START, END, CAPACITY: TRAFFIC"<br>
     * <br>
     * where START and END are different non-empty strings denoting the name of
     * the start location of the corridor and the end location of the corridor,
     * respectively; CAPACITY is a positive integer denoting the capacity of the
     * corridor; and TRAFFIC is a positive integer denoting the amount of
     * traffic from the venue that will use the corridor when the venue hosts
     * the largest event that it can. The strings denoting the start and end
     * locations of the corridor may contain any characters other than a comma
     * (',') or semicolon (':'). Both CAPACITY and TRAFFIC should be positive
     * integers with no additional leading or trailing whitespace. For example,
     * <br>
     * <br>
     * "St. Lucia, Royal Queensland Show - EKKA, 120: 60"<br>
     * <br>
     * represents a traffic corridor from "St. Lucia" to "Royal Queensland Show
     * - EKKA" with a maximum capacity of 120, that will have 60 people from the
     * venue using it when the venue hosts an event of maximum size. <br>
     * <br>
     * Note that the start, end and capacity of a corridor are separated by the
     * string ", ". The corridor and its traffic are separated by ": ". <br>
     * <br>
     * The corridors and their respective traffic may appear in any order (i.e.
     * the corridors aren't necessarily sorted in any way.) Each corridor may
     * only appear once in the traffic description for a venue (i.e. there is
     * only one line for each corridor), and the traffic on that corridor should
     * be less than or equal to the capacity of the venue, and less than or
     * equal to the capacity of the corridor.
     * </p>
     * <p>
     * <p>
     * For (iv) an empty line is a line with no characters at all (i.e. the
     * contents of the line is the empty string "").
     * </p>
     * <p>
     * <p>
     * Two equivalent venues shouldn't appear twice in the file.
     * </p>
     * <p>
     * <p>
     * If a FormatException is thrown, it will have a meaningful message that
     * accurately describes the problem with the input file format, including
     * the line of the file where the problem was detected.
     * </p>
     *
     * @param fileName the name of the file to read from.
     * @return a list of the venues from the file, in the order in which they
     * appear in the file.
     * @throws IOException     if there is an error reading from the input file.
     * @throws FormatException if there is an error with the input format (e.g.
     *                         there is more than one venue description in the
     *                         file that describes the same venue, or the file
     *                         format is not as specified above in any other
     *                         way.) The FormatExceptions thrown should have a
     *                         meaningful message that accurately describes
     *                         the problem with the input file format, including
     *                         the line of the file where the problem was
     *                         detected.
     */
    public static List<Venue> read(String fileName) throws IOException,
            FormatException {
        // scanner for reading the file a line at a time
        Scanner lineScanner;
        // The venue list to be returned
        List<Venue> venues = new ArrayList<>();
        Integer lineNumber = 1;
        lineScanner = new Scanner(new FileReader(fileName));

        while (lineScanner.hasNextLine()) {
            String venueName = readVenueName(lineScanner,
                    ++lineNumber);
            int venueCapacity = readVenueCapacity(lineScanner, ++lineNumber);

            Traffic venueTraffic = readTraffic(lineScanner,
                    lineNumber,
                    venueCapacity);

            //Create the venue after successful read
            Venue v = new Venue(venueName, venueCapacity, venueTraffic);

            //get the lineNumber after readTraffic
            for (Corridor c : venueTraffic.getCorridorsWithTraffic()) {
                lineNumber++;
            }

            if (venues.contains(v)) {
                throw new FormatException(errorMessage(++lineNumber,
                        "duplicate venue detected"));
            }
            venues.add(v);
        }
        lineScanner.close();
        return venues;
    }


    /**
     * Reads venueName from the scanner lineScanner
     *
     * @require param lineScanner != null and open for reading &&
     *          lineScanner at correct part of file to read venueName &&
     *          param lineNumber != null &&
     *          lineNumber == current line of input file
     * @ensure returns a correct venue Name without errors
     *
     * @throws FormatException
     *              If the venue name is ""
     */
    private static String readVenueName(Scanner lineScanner,
                                        Integer lineNumber)
            throws FormatException {
        String venueName = lineScanner.nextLine();
        if (venueName.matches("[^,:]+")) {
            return venueName;
        } else {
            throw new FormatException(errorMessage(lineNumber,
                    "venue name cannot be \"\""));
        }
    }

    /**
     * Reads the venue capacity from a file.
     *
     * @require param lineScanner != null and open for reading &&
     *          lineScanner at correct part of file to read capacity &&
     *          param lineNumber != null &&
     *          lineNumber == current line of input file
     *
     * @ensure returns the capacity, if formatted correctly
     *
     * @throws FormatException if the capacity in file in an invalid format.
     */
    private static int readVenueCapacity(Scanner lineScanner, int lineNumber)
            throws FormatException {
        String result = lineScanner.nextLine();
        try {
            return Integer.parseInt(result);
        } catch (NumberFormatException nfe) {
            throw new FormatException(errorMessage(lineNumber,
                    "venue capacity is invalid"));
        }
    }

    /**
     * Reads through input file, takes in all Corridors for venue
     *
     * @require param lineScanner != null and open for reading &&
     *          lineScanner at correct part of file to read Traffic &&
     *          param lineNumber != null &&
     *          lineNumber is equal to current line of input file &&
     *          param venueCapacity != null &&
     *          venueCapacity > 0
     *
     * @ensure returns the generated traffic of by an event at a venue
     * @throws FormatException if there is no empty line to complete venue"
     */
    private static Traffic readTraffic(Scanner lineScanner,
                                       Integer lineNumber,
                                       int venueCapacity)
            throws FormatException {
        //a duplicate of line, which isn't returned by getGeneratedTraffic
        int feLineNumber = lineNumber;
        ArrayList<String> trafficCorridors = new ArrayList<>();
        while (lineScanner.hasNextLine()) {
            String s = lineScanner.nextLine();
            if (!s.equals("")) {
                trafficCorridors.add(s);
                feLineNumber++;
            } else {
                return getGeneratedTraffic(lineNumber,
                        trafficCorridors,
                        venueCapacity);
            }
        }
        throw new FormatException(errorMessage(feLineNumber,
                "empty line expected to complete venue"));
    }

    /**
     * Gets the generated traffic of a venue from a list of strings
     *
     * @requre param lineNumber >= 0 &&
     *         lineNumber is equal to current line of input file &&
     *         param trafficCorridors.size() > 0 &&
     *         param venueCapacity >= 0
     *
     * @ensure returns the generated traffic of an event on each corridor
     * @throws FormatException If the traffic is missing from file
     *                         If the traffic exceeds venue capacity
     *                         If the same corridor appears more than once
     *                         for venue
     */
    private static Traffic getGeneratedTraffic(
            Integer lineNumber,
            ArrayList<String> trafficCorridors,
            int venueCapacity) throws FormatException {

        ArrayList<Corridor> corridors = new ArrayList<>();
        Traffic t = new Traffic();
        for (String s : trafficCorridors) {
            String[] s2 = s.split(":");
            if (s2.length != 2) {
                throw new FormatException(errorMessage(lineNumber,
                        "traffic is missing"));
            }
            int generatedTraffic = Integer.parseInt(s2[1].trim());
            if (generatedTraffic > venueCapacity) {
                throw new FormatException(errorMessage(lineNumber,
                        "Traffic exceeds venue capacity"));
            }
            Corridor c = readCorridor(s2[0], generatedTraffic, lineNumber);
            if (corridors.contains(c)) {
                throw new FormatException(errorMessage(lineNumber,
                        "same corridor appears more than once in traffic"));
            }
            corridors.add(c);
            lineNumber++;
            t.updateTraffic(c, generatedTraffic);
        }
        return t;
    }

    /**
     * Takes in a String input and returns a Corridor
     *
     * @require param corridor != null &&
     *          param generatedTraffic >= 0 &&
     *          param lineNumber >= 0
     *
     * @ensure Return a corridor with correct start, end and capacity.
     *
     * @throws FormatException If the corridor is formatted incorrectly,
     *                         either location name is empty.
     */
    private static Corridor readCorridor(String corridor,
                                         int generatedTraffic, int lineNumber)
            throws FormatException {
        String[] corridorArray = corridor.split(", ");
        Location l1 = new Location(corridorArray[0]);
        Location l2 = new Location(corridorArray[1]);
        if (l1.getName().equals("") || l2.getName().equals("")) {
            throw new FormatException(
                    errorMessage(lineNumber,
                            "incorrectly formatted corridor - END is \"\""));
        }
        int capacity = Integer.parseInt(corridorArray[2].trim());
        if (generatedTraffic > capacity) {
            throw new FormatException(errorMessage(lineNumber,
                    "traffic exceeds corridor capacity"));
        }
        return new Corridor(l1, l2, capacity);
    }

    /**
     * Returns a string, with an error message passed in.
     *        example: "Error on line 4: Traffic exceeds venue capacity"
     *
     * @require param message != null &&
     *          param lineNumber is correct number of problem line
     *
     * @ensure Returns an error message for line lineNumber of the file that
     * contains the given message.
     */
    private static String errorMessage(Integer lineNumber, String message) {
        return "Error on line " + lineNumber + ": " + message;
    }

}
